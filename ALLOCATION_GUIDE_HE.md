# 📖 מדריך השיבוץ המלא - TicketSense Allocation Guide

> **מדריך מקיף לכל הלוגיקה, החוקים, והדרכים לשיפור**

---

## 🎯 תוכן עניינים

1. [מה זה?](#מה-זה)
2. [איך זה עובד? (תהליך מלא)](#איך-זה-עובד)
3. [כל החוקים](#כל-החוקים)
4. [האם יש AI?](#האם-יש-ai)
5. [דוגמאות קונקרטיות](#דוגמאות-קונקרטיות)
6. [דרכים לשיפור](#דרכים-לשיפור)
7. [קבצי הגדרה](#קבצי-הגדרה)

---

## מה זה?

### המערכת שלך - TicketSense.ai

מערכת **שיבוץ כרטיסים אוטומטית** לריאל מדריד.

**מה היא עושה:**
- קוראת הזמנות מ-Google Sheets
- קוראת כרטיסים זמינים מ-Google Sheets
- מקצה כרטיסים להזמנות לפי כללי עסק
- כותבת את התוצאות חזרה ל-Google Sheets

**איך היא עובדת:**
- **Rule-Based System** (מבוסס כללים)
- **לא AI** - רק לוגיקה ברורה וקבועה
- מהיר, צפוי, וניתן לשליטה

---

## איך זה עובד?

### 📊 תהליך השיבוץ - Step by Step

```
┌─────────────────────────────────────────────────────────┐
│  שלב 1: קריאת נתונים                                    │
├─────────────────────────────────────────────────────────┤
│  • קורא הזמנות מ-Google Sheets (Orders)                │
│  • קורא כרטיסים מ-Google Sheets (Tickets)              │
│  • בודק אילו הזמנות כבר שובצו (עמודה K)               │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 2: מיון הזמנות                                      │
├─────────────────────────────────────────────────────────┤
│  עדיפות 1 (ABSOLUTE): הזמנות עם בלוק ספציפי            │
│    לדוגמה: "CATEGORY 1 304" → משתמש רק בבלוק 304       │
│                                                            │
│  עדיפות 2: הזמנות לפי קטגוריה                          │
│    CAT1 > CAT2 > CAT3 > CAT4                             │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 3: לכל הזמנה - מציאת בלוקים מותרים                │
├─────────────────────────────────────────────────────────┤
│  3.1 בלוק ספציפי?                                       │
│      אם כן → משתמש רק בו (דילוג על מיפוי)              │
│                                                            │
│  3.2 מיפוי קטגוריה → בלוקים                             │
│      קורא: config/category_mapping/{source}.json         │
│      מחפש התאמה גמישה                                    │
│                                                            │
│  3.3 הוספת Upgrades                                      │
│      מוסיף בלוקים מקטגוריות טובות יותר                  │
│      בודק הגבלות (למשל: Shortside → Lateral חסום)      │
│                                                            │
│  3.4 מיון בלוקים                                         │
│      1. Exclusive (רק המקור הזה)                         │
│      2. Shared (מספר מקורות)                             │
│      3. בתוך כל קבוצה: מספר בלוק (גבוה = זול)          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 4: סינון כרטיסים (Candidates)                      │
├─────────────────────────────────────────────────────────┤
│  לכל כרטיס בודק:                                        │
│  ✅ Game Match?    → המשחק תואם?                        │
│  ✅ Block Match?   → הבלוק מותר?                        │
│  ✅ Not Assigned?  → הכרטיס לא שובץ כבר?                │
│                                                            │
│  אם כל התנאים ✅ → כרטיס הופך ל-Candidate              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 5: סיווג כרטיסים                                   │
├─────────────────────────────────────────────────────────┤
│  המערכת מסווגת כל כרטיס:                                │
│                                                            │
│  SINGLE  → כרטיס בודד (אין סמוכים)                     │
│  PAIR    → זוג צמוד (diff = 2)                           │
│  "N together" → 3+ צמודים                                │
│  SCH     → Single Center Half (פער מושב אחד, diff = 4) │
│  SCH-N   → SCH עם N פערים                                │
│                                                            │
│  איך זה עובד:                                            │
│  1. מקבץ לפי (game, block, row)                          │
│  2. מפריד לפי parity (זוגי/אי-זוגי)                     │
│  3. מחפש רצפים עם diff = 2 (צמודים)                     │
│  4. מחפש SCH עם diff = 4 (פער אחד)                      │
│  5. מחפש SCH diagonal (שורה אחרת)                       │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 6: שיבוץ לפי סוג הזמנה                             │
├─────────────────────────────────────────────────────────┤
│  SINGLE (1 כרטיס):                                       │
│    • IRON RULE: SINGLE אמיתי → רק אותו                   │
│    • Specific Block → יכול לפרק PAIR                     │
│    • Fallback → PAIR או SCH (אם מותר)                   │
│                                                            │
│  MULTIPLE (2+ כרטיסים):                                 │
│    • STRICT: כל הכרטיסים באותו בלוק ושורה                │
│    • Adjacent: diff 2 ✅, diff 4 ✅, diff 6+ ❌          │
│    • Max 1 SCH gap                                        │
│    • Priority לפי מקור (SCH/PAIR)                        │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  שלב 7: כתיבה ל-Google Sheets                           │
├─────────────────────────────────────────────────────────┤
│  • כותב את מספר הזמנה לעמודה K                          │
│  • רק אם התא ריק (לא דורס)                              │
│  • עם retry ו-verification                               │
└─────────────────────────────────────────────────────────┘
```

---

## כל החוקים

### 🔒 Iron Rules (לא ניתן לשנות!)

**1. Specific Block Priority**
```
אם הזמנה מכילה בלוק ספציפי → עדיפות מוחלטת!
דוגמה: "CATEGORY 1 304" → משתמש רק בבלוק 304
```

**2. Don't Break Groups**
```
לא לפרק PAIR/SCH/Group אם יש SINGLE זמין
מטרה: לשמור על כרטיסים ביחד
```

**3. Never Reassign**
```
כרטיס שכבר שובץ (עמודה K לא ריקה) = לא נוגעים בו
מטרה: למנוע דריסה של שיבוצים קיימים
```

**4. Game Must Match**
```
כרטיס חייב להיות לאותו משחק
Flexible matching: "Real Madrid" = "R. MADRID"
```

**5. Block Must Be Allowed**
```
כרטיס חייב להיות בבלוק מותר לקטגוריה/מקור
כולל Upgrades (אם מותר)
```

**6. No Large Gaps**
```
diff 2 = ✅ צמודים (PAIR)
diff 4 = ✅ פער מושב אחד (SCH)
diff 6+ = ❌ אף פעם לא! (פער גדול מדי)
```

### ⚙️ Configurable Rules (ניתן לשנות)

#### Single Rule (`seating_rules.json`)
```json
{
  "single_rule": {
    "strict_single_only": false,  // true = רק SINGLE, false = יכול PAIR/SCH
    "behavior_if_no_single": "USE_PAIR"
  }
}
```

**מה זה אומר:**
- `strict_single_only = true` → אם אין SINGLE, דחייה
- `strict_single_only = false` → אם אין SINGLE, משתמש ב-PAIR/SCH

#### SCH Allowance (לפי מקור)
```json
{
  "sources": {
    "livefootballtickets": {"allow_sch": false},      // לא SCH
    "footballticketnet": {"allow_sch": true},         // מותר SCH
    "goldenseat": {"allow_sch": true, "sch_priority": "last"}  // SCH אחרון
  }
}
```

**מה זה אומר:**
- `allow_sch = false` → רק PAIR (לא SCH)
- `allow_sch = true` → מותר SCH (לפי priority)

#### Pairing Priority
```json
{
  "pairing_priority": {
    "when_allow_sch": ["SCH", "PAIR"],           // SCH לפני PAIR
    "when_disallow_sch": ["PAIR"],               // רק PAIR
    "goldenseat_priority": ["PAIR", "SCH"]       // PAIR לפני SCH
  }
}
```

**מה זה אומר:**
- `when_allow_sch` → אם מותר SCH: SCH לפני PAIR
- `goldenseat_priority` → Goldenseat: PAIR לפני SCH (הפוך!)

#### Protection Rules
```json
{
  "protection": {
    "do_not_break_groups_for_smaller_orders": true,
    "protect_group_sizes": [4, 5, 6]
  }
}
```

**מה זה אומר:**
- לא לפרק קבוצות של 4-6 כרטיסים עבור הזמנות קטנות יותר

### 📊 Business Rules (`category_hierarchy.json`)

#### Category Hierarchy
```
Level 1  = CATEGORY 1 PLATINUM   (הכי טוב)
Level 2  = CATEGORY 1 PREMIUM
Level 3  = CATEGORY 1 GOLD
...
Level 11 = CATEGORY 4            (הכי גרוע)
```

#### Upgrade Rules
- מוסיף בלוקים מקטגוריות טובות יותר
- **חסימה**: Shortside (CAT3/CAT4) → Lateral (CAT2) = ❌ חסום

#### Block Exclusivity
- **Exclusive**: רק מקור אחד יכול להשתמש
- **Shared**: מספר מקורות
- **Priority**: Exclusive לפני Shared

---

## האם יש AI?

### ❌ **לא! זה Rule-Based System**

#### מה זה אומר?
- ❌ אין Machine Learning
- ❌ אין Neural Networks
- ❌ אין "למידה" או "התאמה אוטומטית"
- ✅ רק כללים ברורים וקבועים
- ✅ רק לוגיקה מוגדרת מראש

#### למה זה טוב?
✅ **צפוי וברור** - תמיד יודע מה יקרה  
✅ **ניתן לשליטה** - שינוי כללים = שינוי תוצאה  
✅ **מהיר** - אין חישובים כבדים  
✅ **קל לדיבוג** - אם משהו לא עובד, יודעים למה

#### למה זה פחות טוב?
❌ **לא "חושב"** - רק עוקב אחר כללים  
❌ **לא משתפר** - לא לומד מהניסיון  
❌ **דורש עדכון ידני** - כל שיפור = שינוי קוד

---

## דוגמאות קונקרטיות

### דוגמה 1: הזמנת SINGLE

**הזמנה:**
- מספר: ORD-123
- מקור: livefootballtickets
- קטגוריה: CATEGORY 1 NORMAL
- כמות: 1
- ישיבה: "Single Seat(s)"

**תהליך:**
1. ✅ קטגוריה → בלוקים: [501, 502, 503, ...]
2. ✅ סינון כרטיסים: משחק תואם, בלוק מותר, לא שובץ
3. ✅ סיווג: מחפש SINGLE
4. ✅ אם יש SINGLE → משתמש בו
5. ✅ אם אין → בודק `strict_single_only`
   - `false` → משתמש ב-PAIR
   - `true` → דחייה

**תוצאה:** כרטיס בודד שובץ

---

### דוגמה 2: הזמנת PAIR

**הזמנה:**
- מספר: ORD-456
- מקור: footballticketnet
- קטגוריה: CATEGORY 2 NORMAL
- כמות: 2
- ישיבה: "Up To 2 Together"

**תהליך:**
1. ✅ קטגוריה → בלוקים: [601, 602, 603, ...]
2. ✅ `allow_sch = true` → מותר SCH
3. ✅ Priority: SCH לפני PAIR (לפי `when_allow_sch`)
4. ✅ מחפש 2 כרטיסים צמודים (diff = 2) או SCH (diff = 4)
5. ✅ מעדיף SCH (אם יש)
6. ✅ אם אין SCH → משתמש ב-PAIR

**תוצאה:** 2 כרטיסים צמודים שובצו (SCH או PAIR)

---

### דוגמה 3: הזמנה לבלוק ספציפי

**הזמנה:**
- מספר: ORD-789
- מקור: goldenseat
- קטגוריה: "CATEGORY 1 PREMIUM 304"
- כמות: 1
- ישיבה: "Single Seat(s)"

**תהליך:**
1. ✅ **IRON RULE**: קטגוריה מכילה בלוק ספציפי (304)
2. ✅ **דילוג על מיפוי** - משתמש רק בבלוק 304
3. ✅ סינון: רק כרטיסים מבלוק 304
4. ✅ Specific Block Order → יכול לפרק PAIR
5. ✅ משתמש בכרטיס הראשון מבלוק 304

**תוצאה:** כרטיס בודד מבלוק 304 שובץ (אפילו אם זה פירק PAIR)

---

### דוגמה 4: הזמנה ל-4 כרטיסים

**הזמנה:**
- מספר: ORD-999
- מקור: sportsevents365
- קטגוריה: CATEGORY 3
- כמות: 4
- ישיבה: "Up To 4 Together"

**תהליך:**
1. ✅ קטגוריה → בלוקים: [611, 613, 615, ...]
2. ✅ מחפש 4 כרטיסים באותו בלוק ושורה
3. ✅ בודק שהכרטיסים צמודים:
   - diff 2 ✅ (צמודים)
   - diff 4 ✅ (פער מושב אחד - מותר SCH)
   - diff 6+ ❌ (פער גדול מדי - לא מותר)
4. ✅ Max 1 SCH gap (פער אחד בלבד)
5. ✅ מעדיף strictly adjacent (ללא פערים)
6. ✅ אם אין → עם SCH gap (אם מותר)

**תוצאה:** 4 כרטיסים צמודים שובצו (או עם פער SCH אחד)

---

## דרכים לשיפור

### 🚀 קצר טווח (קל ליישום)

#### 1. Dynamic Priority
**מה:** עדיפות דינמית לפי זמן/ערך
```python
# במקום רק קטגוריה, לקחת בחשבון:
priority = base_category_level
- age_bonus  # הזמנות ישנות יותר = עדיפות
- value_bonus  # הזמנות יקרות יותר = עדיפות
```

**למה:** הזמנות ישנות יותר צריכות עדיפות

#### 2. Better Logging
**מה:** לוגים מפורטים יותר
```python
# במקום רק "שובץ", לוג:
- למה נבחר הבלוק הזה?
- כמה candidates היו?
- למה לא נבחרו אחרים?
```

**למה:** ניתוח טוב יותר של כשלונות

#### 3. Statistics Dashboard
**מה:** מדדים על הצלחה
- כמה % מההזמנות שובצו?
- כמה זמן לקח?
- אילו סוגי הזמנות נכשלו?

**למה:** הבנה טובה יותר של ביצועים

---

### 🎯 בינוני טווח (בינוני ליישום)

#### 1. Multi-Pass Optimization
**מה:** מספר passes לשיפור
```
Pass 1: שיבוץ "קל" (SINGLE, PAIR ברור)
Pass 2: שיבוץ "מורכב" (SCH, groups)
Pass 3: Re-optimization (האם אפשר לשפר?)
```

**למה:** שימוש טוב יותר בכרטיסים

#### 2. Smart Block Selection
**מה:** בחירת בלוקים חכמה יותר
- לא רק "exclusive first"
- אלא: בלוקים עם הכי הרבה כרטיסים פנויים
- בלוקים שמתאימים למספר הזמנות

**למה:** מיקסום שימוש בכרטיסים

#### 3. Feedback Collection
**מה:** איסוף נתונים על כשלונות
- למה הזמנה נכשלה?
- כמה כרטיסים היו זמינים?
- אילו בלוקים היו מותרים?

**למה:** הבנה טובה יותר של בעיות

---

### 🧠 ארוך טווח (קשה ליישום)

#### 1. Machine Learning
**מה:** למידה מהניסיון
- אילו שיבוצים הצליחו?
- חיזוי הצלחת שיבוץ לפני ביצוע
- אופטימיזציה של סדר הזמנות

**למה:** שיפור אוטומטי עם הזמן

#### 2. Mathematical Optimization
**מה:** חישוב מיטבי גלובלי
- לא רק "הזמנה אחר הזמנה"
- אלא: חישוב השילוב המיטבי של כל ההזמנות
- מיקסום מספר שיבוצים מוצלחים

**למה:** תוצאות מיטביות (optimal)

#### 3. Predictive Analytics
**מה:** חיזוי עתידי
- אילו הזמנות יגיעו?
- מתי יהיה יותר מלאי?
- איך לתכנן מראש?

**למה:** תכנון טוב יותר

---

## קבצי הגדרה

### 📁 מבנה הקבצים

```
TicketSense/
├── config/
│   ├── seating_rules.json        ← כללי ישיבה (SCH, PAIR, etc.)
│   ├── category_hierarchy.json   ← היררכיית קטגוריות
│   ├── category_mapping/         ← מיפוי קטגוריה → בלוקים
│   │   ├── livefootballtickets.json
│   │   ├── footballticketnet.json
│   │   ├── sportsevents365.json
│   │   ├── tixstock.json
│   │   └── goldenseat.json
│   └── local_settings.json       ← הגדרות משתמש
│
├── engine/
│   ├── allocator.py              ← הלוגיקה העיקרית
│   └── seat_classifier.py        ← סיווג כרטיסים (SINGLE/PAIR/SCH)
│
└── main.py                       ← האינטגרציה עם Google Sheets
```

### 📝 איך לשנות כללים?

#### לשנות כללי ישיבה:
ערוך `config/seating_rules.json`:
```json
{
  "single_rule": {
    "strict_single_only": false  // שנה ל-true אם רוצה רק SINGLE
  },
  "sources": {
    "livefootballtickets": {
      "allow_sch": true  // שנה ל-true אם רוצה לאפשר SCH
    }
  }
}
```

#### לשנות היררכיית קטגוריות:
ערוך `config/category_hierarchy.json`:
```json
{
  "priority_order": [
    {"level": 1, "name": "CATEGORY 1 PLATINUM"},
    // הוסף או שנה קטגוריות
  ]
}
```

#### לשנות מיפוי קטגוריות:
ערוך `config/category_mapping/{source}.json`:
```json
{
  "CATEGORY 1 NORMAL": [501, 502, 503],  // שנה בלוקים
  // הוסף קטגוריות חדשות
}
```

---

## 📊 סיכום

### מה יש עכשיו:
✅ Rule-Based System יציב וצפוי  
✅ כללים ברורים וניתנים לשליטה  
✅ עובד טוב למקרים רגילים  

### מה חסר:
❌ למידה מהניסיון  
❌ אופטימיזציה גלובלית  
❌ התאמה דינמית  

### מה כדאי להוסיף:
1. **קצר טווח**: Dynamic Priority, Better Logging
2. **בינוני טווח**: Multi-Pass, Smart Selection
3. **ארוך טווח**: ML, Optimization

**המלצה:** התחל בשיפורים קצרי טווח, אסוף נתונים, ואז תחליט אם להוסיף ML.

---

## 📞 שאלות נפוצות

**Q: למה הזמנה מסוימת לא שובצה?**  
A: בדוק את הלוגים - המערכת מפרטת למה:
- אין כרטיסים זמינים?
- בלוק לא מותר?
- משחק לא תואם?

**Q: איך לשנות priority של מקור?**  
A: ערוך `seating_rules.json` → `pairing_priority`

**Q: איך להוסיף מקור חדש?**  
A: 
1. צור `config/category_mapping/newsource.json`
2. הוסף ל-`seating_rules.json` → `sources`

**Q: למה בלוק מסוים לא נבחר?**  
A: בדוק:
- האם הבלוק במיפוי?
- האם יש כרטיסים זמינים בו?
- האם הוא Exclusive או Shared?

---

**עוד שאלות?** בדוק את הלוגים ב-`logs/allocation.log`!
